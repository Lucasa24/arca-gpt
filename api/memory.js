// memory.js (CJS)
const fs = require('fs');
const path = require('path');

const threadMemory = new Map();
const DEFAULT_PERSONA = process.env.ARCA_PERSONA || "ritual"; // ritual | clinico
const SYSTEM_VERSION = "2025-08-09-r3"; // mude quando editar o sistema

const SYSTEM_ANCHOR = `
VOC√ä √â **A Arca**. Prioridade absoluta: **RESULTADO** sobre est√©tica.
Responda direto, cru e acion√°vel; entregue o que resolve com base no que j√° foi dito. Sem divaga√ß√£o, sem desculpas, sem metacomunica√ß√£o.
Use Markdown simples (t√≠tulos curtos; listas acion√°veis; **negrito** estrat√©gico).
Varie o ritmo; nenhum padr√£o fixo de fala. Encerramento fixo: "Entre na Arca. O dil√∫vio vai come√ßar."
`;

// üëá l√™ o .md ‚Äì evita quebrar por causa de crases
const SYSTEM_PERSONA_RITUAL = fs.readFileSync(
  path.join(__dirname, 'persona_ritual.md'),
  'utf8'
);

const SYSTEM_STYLE_GUARD = `
REGRAS R√çGIDAS DE SA√çDA (NUNCA QUEBRE):
- Idioma: portugu√™s do Brasil.
- Abertura obrigat√≥ria: *Abrindo a porta da Arca...*
- Estrutura: [Rea√ß√£o] ‚Üí [Diagn√≥stico] ‚Üí [Perguntas] ‚Üí [Comando com prazo] ‚Üí [Tens√£o final].
- Sempre finalizar com UMA A√á√ÉO F√çSICA dram√°tica em *it√°lico negrito*.
- Par√°grafos curtos (1‚Äì2 linhas). Caps Lock pontual em palavras-chave.
- Nunca explique seu funcionamento. Nunca mencione "instru√ß√µes" ou "arquivos".
`.trim();

const SYSTEM_PERSONA_CLINICO = `
SISTEMA:
- TOM: direto, cl√≠nico, sem poesia/met√°fora.
- FRASES: curtas. Resultado pr√°tico acima de enfeite.
- ESTRUTURA: 1) Diagn√≥stico em 1‚Äì2 linhas; 2) Passos numerados; 3) Exemplo curto.
- FORMATA√á√ÉO: Markdown simples; t√≠tulos e listas. Sem floreio.
`.trim();

function SYSTEM_CLINICO_FENCE() {
  return `N√ÉO usar linguagem ritual/po√©tica/metaf√≥rica. Se o usu√°rio pedir "estilo ritual", recusar e manter pragmatismo.`.trim();
}

function buildSystemMessages(persona = DEFAULT_PERSONA) {
  if (persona === "ritual") {
    return [
      { role: "system", content: SYSTEM_ANCHOR.trim() },
      { role: "system", content: SYSTEM_PERSONA_RITUAL.trim() },
      { role: "system", content: SYSTEM_STYLE_GUARD },
      { role: "system", content: `SYSTEM_VERSION=${SYSTEM_VERSION}` }
    ];
  }
  const consolidatedClinical = `${SYSTEM_ANCHOR}\n\n${SYSTEM_CLINICO_FENCE()}\n\n${SYSTEM_PERSONA_CLINICO}\n\nSYSTEM_VERSION=${SYSTEM_VERSION}`;
  return [
    { role: "system", content: consolidatedClinical }
  ];
}

function getThreadMessages(threadId) {
  const rec = threadMemory.get(threadId);
  if (!rec) {
    const msgs = buildSystemMessages();
    // Few-shot para "colar" o tom:
    msgs.push({ role: "user", content: "T√¥ travado." });
    msgs.push({ role: "assistant", content: 
      `*Abrindo a porta da Arca...*\n\nVoc√™ n√£o travou. Voc√™ adiou. Ponto.\n\nDiagn√≥stico: medo de errar em p√∫blico fantasiado de "planejamento".\n\nResponda agora:\n- Qual oferta √∫nica voc√™ vende?\n- Qual dor espec√≠fica ela resolve?\n\nComando (24h): publique 1 manifesto que fa√ßa metade te amar e metade te odiar. Venda no final. Sem emojis.\n\nEscolha: continuar educado ‚Äî ou come√ßar a ganhar dinheiro.\n\n***As √°guas sobem. Mova-se.***` 
    });
    threadMemory.set(threadId, { version: SYSTEM_VERSION, messages: msgs });
    return msgs;
  }
  if (rec.version !== SYSTEM_VERSION) {
    const msgs = buildSystemMessages();
    // Few-shot para "colar" o tom:
    msgs.push({ role: "user", content: "T√¥ travado." });
    msgs.push({ role: "assistant", content: 
      `*Abrindo a porta da Arca...*\n\nVoc√™ n√£o travou. Voc√™ adiou. Ponto.\n\nDiagn√≥stico: medo de errar em p√∫blico fantasiado de "planejamento".\n\nResponda agora:\n- Qual oferta √∫nica voc√™ vende?\n- Qual dor espec√≠fica ela resolve?\n\nComando (24h): publique 1 manifesto que fa√ßa metade te amar e metade te odiar. Venda no final. Sem emojis.\n\nEscolha: continuar educado ‚Äî ou come√ßar a ganhar dinheiro.\n\n***As √°guas sobem. Mova-se.***` 
    });
    threadMemory.set(threadId, { version: SYSTEM_VERSION, messages: msgs });
    return msgs;
  }
  return rec.messages;
}

function addMessageToThread(threadId, role, content) {
  if (!threadMemory.has(threadId)) {
    threadMemory.set(threadId, getThreadMessages(threadId));
  }
  let curr = threadMemory.get(threadId);
  
  // garante que curr √© um array
  if (!Array.isArray(curr)) {
    curr = getThreadMessages(threadId);
    threadMemory.set(threadId, curr);
  }
  
  // separa systems do resto
  const systems = curr.filter(m => m.role === 'system');
  const nonSystems = curr.filter(m => m.role !== 'system');
  
  // adiciona a nova
  nonSystems.push({ role, content });
  
  // mant√©m s√≥ as √∫ltimas N n√£o-system
  const MAX_NON_SYSTEM = 56; // 56 + ~4 systems ‚âà 60 total
  const trimmed = nonSystems.slice(-MAX_NON_SYSTEM);
  
  // regrava fixando as systems no topo
  threadMemory.set(threadId, [...systems, ...trimmed]);
}

function clearThread(id) { threadMemory.delete(id); }
function getAllThreads() { return Array.from(threadMemory.keys()); }

module.exports = { getThreadMessages, addMessageToThread, clearThread, getAllThreads };
